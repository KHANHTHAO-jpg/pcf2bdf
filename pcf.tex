\documentclass{jarticle}

\usepackage[dvips]{graphicx}
\usepackage{alltt}

\newcommand{\RM}{\rmfamily}
\newcommand{\SF}{\sffamily}
\newcommand{\IT}{\itshape}
\newcommand{\BF}{\bfseries}
\newcommand{\B}{\bfseries}
\newcommand{\BSF}{\BF\SF}

\newcommand{\VSP}{\vspace{2ex}}
\newcommand{\　}{\hspace*{1em}}
\newcommand{\SP}[1]{\setbox0=\hbox{#1}\rule{\wd0}{0pt}}
\newcommand{\SSP}[2]{\setbox0=\hbox{#1}\setbox1=\hbox{#2}\dimen0=\wd0\advance\dimen0 by -\wd1\rule{\dimen0}{0pt}}
\newcommand{\SSSP}[2]{#1\SSP{#2}{#1}}

\newcommand{\■}{\rule{.5em}{.5em}\hspace{1em}}

\begin{document}

\begin{center}
{\Large\BF PCF : Portable Compiled Format}
\end{center}

\vspace{6ex}

\section{はじめに}

X Window System では, ラスタフォントは BDF (Bitmap Distribution
Format) で配布されています. X サーバは PCF (Portable Compiled Format) 
を利用しますので, {\SF bdftopcf} というプログラムで変換する必要があり
ます.

BDF については, X のソースツリーの {\SF/xc/doc/hardcopy/BDF/} に文書が
ありフォーマットが規定されていますが, PCF ファイルのフォーマットは見当
たりません. ここでは, X Version 11, Release 6 の 
{\SF/xc/lib/font/bitmap/pcfread.c}, {\SF pcfwrite.c} などから分かった,
PCF ファイルのフォーマットについて説明します.

\section{定義}

最初に, いくつか定義をしておきます.

\subsection{型}

PCF ファイル中にはさまざまな値が入っていますが, ここではそれを C 言語
風な記述で書いていきます. その時に型は, 大きさとエンディアンをはっきり
わからないものは {\IT Type\/Size$^{Endien}$} と書き表すことにしま
す. 例えば以下のようになります.

\begin{center}
\begin{tabular}{llll}
型                  & {\IT Type}      & {\IT Size}(bits) & {\IT Endien}\\\hline
$char8$             & char            & 8                & なし   \\
$bool8$             & bool            & 8                & なし   \\
$int32^{little}$    & long            & 32               & little \\
$type32^{little}$   & enum type32     & 32               & little \\
$format32^{little}$ & struct format32 & 32               & little \\
\end{tabular}
\end{center}

\subsection{セクション}

PCF ファイルは幾つかの部分に分かれています. その部分部分を{\BF セクショ
ン}と呼ぶことにします\footnote{X Consortium がどんな名前で呼んでいるか
は知らないが, ここではセクションと呼ぶことにする}.

各セクションの最初には, $format32^{little}$ 型の値 {\BSF format} が入ってお
り, これは次のように定義されます.

\subsection{$format32$}

{\SF\noindent
struct $format32$
\footnote{ビットフィールドは, 上のメンバから MSB, 下のメンバほど LSB 
になるように配置されるとします} \{\\
\begin{tabular}{lllll}
 & $uint32$ & \BF id    & :24; & // 下記の 4 つのうちどれか\\
 & $uint32$ & \BF dummy & :2;  & // = 0; padding\\
 & $uint32$ & \BF scan  & :2;  & // (1$<<${\BF scan}) バイトごとに bitmap を読む\\
 & $uint32$ & \BF bit   & :1;  & // 0:LSB first, 1:MSB first\\
 & $uint32$ & \BF byte  & :1;  & // 0:Little Endien, 1:Big Endien\\
 & $uint32$ & \BF glyph & :2;  & // グリフの 1 ラインは (1$<<${\BF glyph}) バイトアライン\\
\end{tabular}\\
\};}\VSP

各セクションの中で特に断りなく $int32$ などが出てきた場合は, 各セクショ
ンの最初の {\BSF format} のメンバ {\BSF byte} を参照して, エンディアン
を決めます.

上記のメンバ {\BSF id} の値は以下のいずれかになります.

\VSP{\SF\noindent
enum \{\\
\begin{tabular}{lll}
 & PCF\_DEFAULT\_FORMAT     & = 0,\\
 & PCF\_INKBOUNDS           & = 2,\\
 & PCF\_ACCEL\_W\_INKBOUNDS & = 1,\\
 & PCF\_COMPRESSED\_METRICS & = 1,\\
\end{tabular}\\
\};}

\section{ファイルフォーマット}

以下の順番でデータが入っています. 以下の順番を入れ換えることはできませ
ん.

\subsection{Table of Contents}

{\SF\noindent\begin{tabular}{lll}
\■$char8$                & \multicolumn{2}{l}{{\BF version}[4] = \{ 1, 'f', 'c', 'p' \};}\\
\■$int32^{little}$       & {\BF nTables};   &\\
\■ struct \{              &                  &\\
\■\　$type32^{little}$   & {\BF type};      & // セクションの ID\\
\■\　$format32^{little}$ & {\BF format};    & // セクションのフォーマット\\
\■\　$int32^{little}$    & {\BF size};      & // セクションのサイズ\\
\■\　$int32^{little}$    & {\BF offset};    & // セクションのファイル先頭からのオフセット\\
\■\}                     & {\BF tables}[{\BF nTables}]; & \\
\end{tabular}}\VSP

ファイルの先頭は, PCF のマジックである {\BSF version} と, セクションの
情報が格納されています. 各セクションの種類は {\BSF type} で区別され, 
以下のような種類があります.

\VSP{\SF\noindent
enum $type32$ \{\\
\begin{tabular}{lll}
 & PCF\_PROPERTIES        & = (1$<<$0),\\
 & PCF\_ACCELERATORS      & = (1$<<$1),\\
 & PCF\_METRICS           & = (1$<<$2),\\
 & PCF\_BITMAPS           & = (1$<<$3),\\
 & PCF\_INK\_METRICS      & = (1$<<$4),\\
 & PCF\_BDF\_ENCODINGS    & = (1$<<$5),\\
 & PCF\_SWIDTHS           & = (1$<<$6),\\
 & PCF\_GLYPH\_NAMES      & = (1$<<$7),\\
 & PCF\_BDF\_ACCELERATORS & = (1$<<$8),\\
\end{tabular}\\
\};}

\subsection{セクション:Properties}

このセクションの種類は {\SF{\BF tables}[$i$].{\BF type} =
PCF\_PROPERTIES} です.

\VSP{\SF\noindent\begin{tabular}{lll}
\■$format32^{little}$ & {\BF format};       & // {\BF format}.{\BF id} = PCF\_DEFAULT\_FORMAT\\
\■$int32$             & {\BF nProps};       &\\
\■ struct \{           &                     &\\
\■\　$int32$          & {\BF name};         &\\
\■\　$bool8$          & {\BF isStringProp}; &\\
\■\　$int32$          & {\BF value};        &\\
\■\}                  & {\BF props}[{\BF nProps}]; &\\
\■$byte8$             & {\BF dummy}[$n$];   & // $n$ = 3 - ((sizeof(props) + 3) \% 4); padding\\
\■$int32$             & {\BF stringSize};   &\\
\■$char8$             & {\BF string}[{\BF stringSize}]; &\\
\end{tabular}}\VSP

このセクションには, フォントのプロパティが格納されています. 主に, BDF 
ファイルの STARTPROPERTIES と ENDPROPERTIES で囲まれた部分の値になって
います.

{\SF{\BF props}[$i$].{\BF name}} は, {\BSF string} からのオフセットで,
{\SF($char8$ *)({\BF string} + {\BF props}[$i$].{\BSF name})} がそのプ
ロパティの名前になります. また, {\SF{\BF props}[$i$].{\BF
isStringProp}} が真ならば, {\SF{\BF props}[$i$].{\BF value}} も文字列
を指しているので, {\SF($char8$ *)({\BF string} + {\BF
props}[$i$].{\BSF value})} がそのプロパティの値となります. それぞれの
文字列の終端には, {\SF '\verb|\|0'} が含まれています.

どのような種類のプロパティがあるか, またどのような種類のプロパティが必
須であるかなどは, X Logical Font Description Conventions
({\SF/xc/doc/hardcopy/XLFD/}) を参照してください.

\subsection{セクション:Accelerators}\label{Section:Accelerators}

このセクションの種類は {\SF{\BF tables}[$i$].{\BF type} =
PCF\_ACCELERATORS} です. もし \ref{Section:BDFAccelerators} セクション:
BDF Accelerators ({\SF PCF\_BDF\_ACCELERATORS}) が存在するならば, この
セクションは無視されますので, その場合は省略可能です. PCF ファイルを作
成する場合は, このセクションではなく BDF Accelerators セクションを使う
ことが推奨されています
\footnote{しかしなにが違うのかよくわからん…}.

\VSP{\SF\noindent\begin{tabular}{lll}
\■$format32^{little}$ & {\BF format};          & // {\BF format}.{\BF id} = PCF\_DEFAULT\_FORMAT\\
\■                    &                        & // or PCF\_ACCEL\_W\_INKBOUNDS\\
\■$bool8$             & {\BF noOverlap};       &\\
\■$bool8$             & {\BF constantMetrics}; &\\
\■$bool8$             & {\BF terminalFont};    &\\
\■$bool8$             & {\BF constantWidth};   &\\
\■$bool8$             & {\BF inkInside};       &\\
\■$bool8$             & {\BF inkMetrics};      &\\
\■$bool8$             & {\BF drawDirection};   &\\
\■$bool8$             & {\BF dummy};           & // padding\\
\■$int32$             & {\BF fontAscent};      &\\
\■$int32$             & {\BF fontDescent};     &\\
\■$int32$             & {\BF maxOverlap};      &\\
\■$metric\_t$         & {\BF minBounds};       &\\
\■$metric\_t$         & {\BF maxBounds};       &\\
\multicolumn{3}{l}{\■\#if {\BF format}.{\BF id} == PCF\_ACCEL\_W\_INKBOUNDS} \\
\■\　$metric\_t$      & {\BF ink\_minBounds};  &\\
\■\　$metric\_t$      & {\BF ink\_maxBounds};  &\\
\multicolumn{3}{l}{\■\#endif} \\
\end{tabular}}\VSP

$metric\_t$ については \ref{Section:Metrics} セクション:Metrics を参照
してください.

このセクションにはフォント全体についての幾つかの特徴が記されていま
す. 詳しくは以下のようになります.

\begin{quote}\footnotesize\SF
\begin{description}
\item[{\BSF noOverlap}] true if:\\
$max_i$({\BF metrics}[$i$].{\BF rightSideBearing} -
        {\BF metrics}[$i$].{\BF characterWidth})\\
       $<=$ {\BF minbounds}.{\BF leftSideBearing}
\item[{\BSF constantMetrics}] true if: 全ての文字のメトリック情報が同じ
\item[{\BSF terminalFont}] true if:\\
$\forall i$ ({\BF constantMetrics} \&\&\\
{\BF metrics}[$i$].{\BF leftSideBearing} == 0 \&\&\\
{\BF metrics}[$i$].{\BF rightSideBearing} ==
{\BF metrics}[$i$].{\BF characterWidth} \&\&\\
{\BF metrics}[$i$].{\BF ascent} == {\BF fontAscent} \&\&\\
{\BF metrics}[$i$].{\BF descent} == {\BF fontDescent})
\item[{\BSF constantWidth}] true if:\\
{\BF minbounds}.{\BF characterWidth} ==
{\BF maxbounds}.{\BF characterWidth}
\item[{\BSF inkInside}] true if:\\
$\forall i$ (0 $<=$ {\BF metrics}[$i$].{\BF leftSideBearing} \&\&\\
{\BF metrics}[$i$].{\BF rightSideBearing} $<=$
{\BF metrics}[$i$].{\BF characterWidth} \&\&\\
-{\BF fontDescent} $<=$ {\BF metrics}[$i$].{\BF ascent} $<=$ {\BF fontAscent} \&\&\\
-{\BF fontAscent} $<=$ {\BF metrics}[$i$].{\BF descent} $<=$ {\BF fontDescent})
\item[{\BSF inkMetrics}] true if: Ink Metrics != Metrics
\item[{\BSF drawDirection}] true if: 右から左, false if: 左から右
\item[{\BSF fontAscent}] フォント全体の Ascent
\item[{\BSF fontDescent}] フォント全体の Descent
\item[{\BSF maxOverlap}] 最も大きい重なり
\item[{\BSF minBounds}] 文字のメトリック情報で各々の最小のもの
\item[{\BSF maxBounds}] 文字のメトリック情報で各々の最大のもの
\item[{\BSF ink\_minBounds}] 文字のドットがある部分のメトリック情報で各々の最大のもの
\item[{\BSF ink\_maxBounds}] 文字のドットがある部分のメトリック情報で各々の最小のもの
\end{description}
\end{quote}

\subsection{セクション:Metrics}\label{Section:Metrics}

このセクションの種類は {\SF{\BF tables}[$i$].{\BF type} = PCF\_METRICS} 
です.

\VSP{\SF\noindent\begin{tabular}{lll}
\■$format32^{little}$     & \multicolumn{2}{l}{{\BF format};\SP{mmm}// {\BF format}.{\BF id} = PCF\_DEFAULT\_FORMAT}\\
\■                        & \multicolumn{2}{l}{\SP{{\BF format};mmm}// or PCF\_COMPRESSED\_METRICS}\\
\multicolumn{3}{l}{\■\#if {\BF format}.{\BF id} == PCF\_DEFAULT\_FORMAT} \\
\■\　$int32$              & {\BF nMetrics};               &\\
\■\　$metric\_t$          & {\BF metrics}[{\BF nMetrics}];&\\
\multicolumn{3}{l}{\■\#else // if {\BF format}.{\BF id} == PCF\_COMPRESSED\_METRICS} \\
\■\　$int16$              & {\BF nMetrics};               &\\
\■\　$compressedMetric\_t$& {\BF cmetrics}[{\BF nMetrics}];&\\
\multicolumn{3}{l}{\■\#endif} \\
\end{tabular}}\VSP

$metric\_t$ は以下のように定義されています (図 \ref{figure:metric}).

\VSP{\SF\noindent
struct $metric\_t$ \{\\
\begin{tabular}{lll}
\　$int16$ & {\BF leftSideBearing};  &\\
\　$int16$ & {\BF rightSideBearing}; &\\
\　$int16$ & {\BF characterWidth};   &\\
\　$int16$ & {\BF ascent};           &\\
\　$int16$ & {\BF descent};          &\\
\　$int16$ & {\BF attributes};       &\\
\end{tabular}\\
\};}\VSP

\begin{figure}[h]
\begin{center}
\includegraphics{metric.eps}
\end{center}
\caption{$metric\_t$}
\label{figure:metric}
\end{figure}

{\BF O} を原点として, {\BSF leftSideBearing} はグリフの左端の $x$ 座標, 
逆に {\BSF rightSideBearing} はグリフの右端の $x$ 座標. {\BSF ascent} 
はベースライン ($x$ 軸) より上にある部分のグリフの高さ, 逆に {\BSF
descent} は下にある部分の高さ. $\overrightarrow{nextChar} = (${\BSF
characterWidth}$, 0)$ は, 現在の文字の原点 {\BF O} から, 次の文字の原
点までのベクトルとなります.

{\SF $metric\_t$ m} と BDF ファイルの関係は次のようになっています.

\VSP{\noindent
\begin{tabular}{ll}
BBX & {\SF BBw BBh BBox BBoy}\\
ATTRIBUTES & {\SF m.{\BF attributes}}\\
\end{tabular}\\
ただし,\\{\SF
\begin{tabular}{lll}
BBw  & = & m.{\BF rightSideBearing} - m.{\BF leftSideBearing}\\
BBh  & = & m.{\BF ascent} + m.{\BF descent}\\
BBox & = & m.{\BF leftSideBearing}\\
BBoy & = & - m.{\BF descent}\\
\end{tabular}
}}\VSP

$compressedMetric\_t$ は以下のように定義されています.

\VSP{\SF\noindent
struct $compressedMetric\_t$ \{\\
\begin{tabular}{lll}
\　$uint8$ & {\BF leftSideBearing};  &\\
\　$uint8$ & {\BF rightSideBearing}; &\\
\　$uint8$ & {\BF characterWidth};   &\\
\　$uint8$ & {\BF ascent};           &\\
\　$uint8$ & {\BF descent};          &\\
\end{tabular}\\
\};}\VSP

$compressedMetric\_t$ {\SF cm} は以下のようにすれば $metric\_t$ {\SF
m} に変換することができますので, {\BSF cmetrics} は {\BSF metrics} と
同一視できます (この文章のなかで {\BSF metrics} を参照している部分があっ
ても, PCF ファイルによっては {\BSF cmetrics} を参照していることになる
ので注意してください).

\VSP{\SF\noindent
\begin{tabular}{llll}
m.{\BF leftSideBearing } &=& ($int16$)cm.{\BF leftSideBearing } &- 0x80;\\
m.{\BF rightSideBearing} &=& ($int16$)cm.{\BF rightSideBearing} &- 0x80;\\
m.{\BF characterWidth  } &=& ($int16$)cm.{\BF characterWidth  } &- 0x80;\\
m.{\BF ascent          } &=& ($int16$)cm.{\BF ascent          } &- 0x80;\\
m.{\BF descent         } &=& ($int16$)cm.{\BF descent         } &- 0x80;\\
m.{\BF attributes      } &=& 0;&\\
\end{tabular}
}\VSP

\subsection{セクション:Bitmaps}

このセクションの種類は {\SF{\BF tables}[$i$].{\BF type} = PCF\_BITMAPS} 
です.

\VSP{\SF\noindent\begin{tabular}{lll}
\■$format32^{little}$ & \multicolumn{2}{l}{{\BF format};\SP{mmm}// {\BF format}.{\BF id} = PCF\_DEFAULT\_FORMAT}\\
\■$int32$  & \multicolumn{2}{l}{{\BF nBitmaps} = {\BF nMetrics};} \\
\■$uint32$ & {\BF bitmapOffsets}[{\BF nBitmaps}]; &\\
\■$uint32$ & {\BF bitmapSizes}[GLYPHPADOPTIONS]; &\\
\■$byte8$  & {\BF bitmaps}[{\BF bitmapSizes}[{\BF format}.{\BF glyph}]]; &\\
\end{tabular}}\VSP

{\SF GLYPHPADOPTIONS} は以下のように定義されています.

\VSP{\SF\noindent
\#define GLYPHPADOPTIONS 4
}\VSP

さて, {\SF{\BF metrics}[$i$]} に対応する文字のグリフはビットマップと
して {\SF($byte8$~*)({\BF bitmaps} + {\BF bitmapOffsets}[$i$])} から始まり
ます.

ビットマップの中の各バイトは, {\SF{\BF format}.{\BF bit}} にしたがって,
LSB first か MSB first でならんでいます.  そして, もし, {\SF {\BF
format}.{\BF byte} != {\BF format}.{\BF bit}} ならば, {\SF 1$<<${\BF
format}.{\BF scan}} バイト毎にバイト順序が入れ換えられて格納されま
す. 図 \ref{figure:MSBLSB} は {\SF 1$<<${\BF format}.{\BF scan} = 4} 
の時の場合です\footnote{実際の例では, Linux の {\SF bdftopcf} は {\SF
1$<<${\BF format}.{\BF scan} = 1, {\BF format}.{\BF bit} = 0, {\BF
format}.{\BF byte} = 0, 1$<<${\BF format}.{\BF glyph} = 4} で PCF ファ
イルを作成します}.

\begin{figure}[h]
\begin{center}
\includegraphics{msblsb.eps}
\end{center}
\caption{グリフの PCF ファイル中でのバイト表現}
\label{figure:MSBLSB}
\end{figure}

又, ビットマップ中の横 1 ラインは, {\SF 1$<<${\BF format}.{\BF glyph}} 
バイト毎にアラインメントされます. 例えば, グリフの幅が 14 ドットの時
\footnote{\SF{\BF metrics}[$i$].{\BF rightSideBearing} - {\BF
metrics}[$i$].{\BF leftSideBearing} = 14} でも, {\SF {\BF format}.{\BF
glyph} = 2} (つまり 4 バイト) ならば, 1 ラインは 4 バイト分 (32 ドット) 
必要になります.

{\SF{\BF bitmapSizes}[$i$]} にはビットマップ中の横 1 ラインが $1<<i$ 
バイト毎にアラインメントされた場合の {\BSF bitmaps} に必要なバイト数が
格納されています. 

\subsection{セクション:Ink Metrics}

このセクションの種類は {\SF{\BF tables}[$i$].{\BF type} =
PCF\_INK\_METRICS} です.

このセクションは X サーバにとっては必要ないので, 省略可能です.

このセクションは, \ref{Section:Metrics} セクション:Metrics と全く同じ
構造をしているので, 説明は省略します.

\subsection{セクション:Encodings}

このセクションの種類は {\SF{\BF tables}[$i$].{\BF type} =
PCF\_BDF\_ENCODINGS}です.

\VSP{\SF\noindent\begin{tabular}{lll}
\■$format32^{little}$ & {\BF format}; & // {\BF format}.{\BF id} = PCF\_DEFAULT\_FORMAT\\
\■$int16$ & {\BF firstCol}; &\\
\■$int16$ & {\BF lastCol};  &\\
\■$int16$ & {\BF firstRow}; &\\
\■$int16$ & {\BF lastRow}; &\\
\■$int16$ & {\BF defaultCh}; & // default character or NO\_SUCH\_CHAR (= -1)\\
\■$int16$ & {\BF encodings}[$n$]; & // $n$ = ({\BF lastCol} - {\BF firstCol} + 1) * ({\BF lastRow} - {\BF firstRow} + 1) \\
\end{tabular}}\VSP

このセクションは, 文字コードと PCF ファイル中での文字の出現順序との対
応が格納されています. 

図 \ref{figure:encodings} を見て下さい. これは {\SF k14.pcf} の例です
が, この場合, {\SF $n$ = (0x7E - 0x21 + 1) * (0x74 - 0x21 + 1) = 7896} 
となり,

\VSP{\SF\noindent
$int16$ {\BF encodings}[7896] = \{\\
\begin{tabular}{rrrrrcrrrrr}
{\B 　},&{\B 、},&{\B 。},&{\B ，},&$\cdots$,&{\B ○},&{\B ●},&{\B ◎},&{\B ◇},\\
{\B ◆},&{\B □},&{\B ■},&       &$\cdots$&       ,&    -1,&    -1,&{\B ◯},\\
    -1,&    -1,&       &       &$\cdots$&        &      ,&    -1,&    -1,\\
{\B ぁ},&      &       &       &$\cdots$&        &       &      ,&    -1,\\
       &       &       &       &$\cdots$&        &       &       &      ,\\
{\B 顱},&      &       &       &$\cdots$&        &       &     ,&{\B 髻},\\
{\B 髻},&{\B 鬆},&     &       &$\cdots$&        &    ,&{\B 鵆},&{\B 鵈},\\
{\B 鵝},&{\B 鵞},&{\B 鵤},&    &$\cdots$&    ,&{\B 龕},&{\B 龜},&{\B 龠},\\
{\B 堯},&{\B 槇},&{\B 遙},&{\B 瑤},&$\cdots$,&-1,&    -1,&    -1,&    -1,\\
\end{tabular}\\
\};}\VSP

\noindent というデータが格納されています ({\B ◆} や {\B 龜} は PCF ファ
イル中でその文字の出現順序です). 例えば, {\SF 0x2122 = ``{\B 、}''} の
メトリック情報は, {\SF{\BF metrics}[{\BF encodings}[1]]} となりま
す. {\SF{\BF encodings}[$i$] = - 1} の文字コードのメトリック情報やビッ
トマップはこの PCF ファイルには含まれません. 当然, 7896 から -1 の出現
回数を引いた数は, {\SF k14.pcf} の {\SF{\BF nMetrics} = 6877} と同じに
なります.

\begin{figure}[h]
\begin{center}
\includegraphics{encodings.eps}
\end{center}
\caption{{\SF k14.pcf}}
\label{figure:encodings}
\end{figure}

\subsection{セクション:Swidths}

このセクションの種類は {\SF{\BF tables}[$i$].{\BF type} =
PCF\_SWIDTHS}です.

このセクションは X サーバにとっては必要ないので, 省略可能です.

\VSP{\SF\noindent\begin{tabular}{lll}
\■$format32^{little}$ & {\BF format}; & // {\BF format}.{\BF id} = PCF\_DEFAULT\_FORMAT\\
\■$int32$ & \multicolumn{2}{l}{{\BF nSwidths} = {\BF nMetrics};} \\
\■$int32$ & {\BF swidths}[{\BF nSwidths}]; & \\
\end{tabular}}\VSP

BDF ファイルの SWIDTHS で指定された値が格納されています. 

\subsection{セクション:Glyph Names}

このセクションの種類は {\SF{\BF tables}[$i$].{\BF type} =
PCF\_GLYPH\_NAMES}です.

このセクションは X サーバにとっては必要ないので, 省略可能です.

\VSP{\SF\noindent\begin{tabular}{lll}
\■$format32^{little}$ & \multicolumn{2}{l}{{\BF format};\SP{mmm}// {\BF format}.{\BF id} = PCF\_DEFAULT\_FORMAT}\\
\■$int32$ & \multicolumn{2}{l}{{\BF nGlyphNames} = {\BF nMetrics};} \\
\■$int32$ & {\BF glyphNameOffsets}[{\BF nGlyphNames}]; & \\
\■$int32$ & {\BF glyphNamesSize}; & \\
\■$char8$ & {\BF glyphNames}[{\BF glyphNamesSize}]; & \\
\end{tabular}}\VSP

このセクションにはフォントの名前が格納されています.

$i$ 番目の文字の名前は, {\SF($char8$ *)({\BF glyphNames} + {\BF
glyphNameOffsets}[$i$])} になります. それぞれの文字列の終端には, 
{\SF '\verb|\|0'} が含まれています.

\subsection{セクション:BDF Accelerators}\label{Section:BDFAccelerators}

このセクションの種類は {\SF{\BF tables}[$i$].{\BF type} =
PCF\_BDF\_ACCELERATORS} です.

このセクションは, \ref{Section:Accelerators} セクション:Accelerators 
と全く同じ構造をしているので, 説明は省略します.

Accelerators セクションが存在する場合は, このセクションは存在しないか
もしれません.

\section{pcf2bdf}

{\SF pcf2bdf} を付録としてつけておきます. 適宜参照してみてください.

\VSP{\SF\noindent usage: pcf2bdf [-v] [-o $BDF file$] [$PCF file$]}\VSP

{\SF -v} オプションを使うと, PCF ファイルの中身を見た気になれるかもし
れません. $PCF File$ には圧縮されたものも指定できます (内部で {\SF
gzip} を呼び出しますので, {\SF gzip} がパスの通ったところに必要です). 
BDF ファイルの FONTBOUNDINGBOX は, {\SF bdftopcf} では参照されないので,
{\SF pcf2bdf} では結構いいかげんな値を出力しています. gcc と Visual
C++ 5.0 用の Makefile をつけておきます.

\section{おわりに}

修正歓迎. 追加歓迎. 連絡は nayuta@is.s.u-tokyo.ac.jp まで.

\begin{tabular}{lll}
Version 1.00 & 1998/03/15(日) & by TAGA Nayuta \\
Version 1.01 & 1998/03/21(土) & {\SF pcf2bdf} の Accelerators 周りのバグフィックス\\
             &                & {\SF pcf2bdf} が {\SF gzip} を呼ぶように改良 \\
Version 1.02 & 1998/04/11(土) & Bitmaps セクションの種類が {\SF PCF\_METRICS} になっていたのを訂正 \\
             &                & Accelerators セクションの未完成だった部分を書いた \\
             &                & GLYPHPADOPTIONS は必ず 4 \\
Version 1.03 & 1999/03/01(月) & jlatex でコンパイルした \\
\end{tabular}

\newpage

\tableofcontents

\end{document}
